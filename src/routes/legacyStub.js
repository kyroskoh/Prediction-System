const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');

// Import models
const User = require('../models/User');
const Channel = require('../models/Channel');
const Prediction = require('../models/Prediction');

// Import middleware
const { predictionLimiter, adminLimiter } = require('../middleware/rateLimiter');

// Helper function to get or create legacy user
async function getOrCreateUser(username) {
  let user = await User.findOne({ username: username.toLowerCase() });
  
  if (!user) {
    user = new User({
      username: username.toLowerCase(),
      email: `${username.toLowerCase()}@legacy.local`,
      password: 'legacy-temp-' + Math.random().toString(36),
      role: 'user'
    });
    await user.save();
  }
  
  return user;
}

// Helper function to get or create channel
async function getOrCreateChannel(channelName) {
  let channel = await Channel.findOne({ name: channelName.toLowerCase() });
  
  if (!channel) {
    // Create owner user for the channel
    const owner = await getOrCreateUser(channelName);
    owner.role = 'owner';
    await owner.save();
    
    channel = new Channel({
      name: channelName.toLowerCase(),
      displayName: channelName,
      owner: owner._id
    });
    await channel.save();
  }
  
  return channel;
}

// Helper function to get current prediction for channel
async function getCurrentPrediction(channel) {
  if (channel.currentPrediction) {
    return await Prediction.findById(channel.currentPrediction);
  }
  return null;
}

// Helper function to send legacy response
function sendLegacyResponse(res, message) {
  res.status(200).send(message);
}

// Legacy validation function (same as original)
function isValidPredictionFormat(prediction, maxScore = 13) {
  const parts = prediction.split('-');
  if (parts.length !== 2) return false;
  
  const leftNum = parseInt(parts[0]);
  const rightNum = parseInt(parts[1]);
  
  if (isNaN(leftNum) || isNaN(rightNum)) return false;
  
  if ((leftNum === maxScore && rightNum >= 0 && rightNum <= maxScore) ||
      (rightNum === maxScore && leftNum >= 0 && leftNum <= maxScore)) {
    return true;
  }
  
  return false;
}

// Route: Check health (backward compatibility)\nrouter.get('/', (req, res) => {\n  sendLegacyResponse(res, 'I am alive!');\n});\n\n// Route: Open prediction\nrouter.get('/:channel/open', adminLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const channel = await getOrCreateChannel(channelName);\n    \n    // Close any existing prediction\n    if (channel.currentPrediction) {\n      const currentPrediction = await getCurrentPrediction(channel);\n      if (currentPrediction && currentPrediction.status === 'open') {\n        currentPrediction.status = 'cancelled';\n        await currentPrediction.save();\n      }\n    }\n    \n    // Create new prediction\n    const owner = await User.findById(channel.owner);\n    const newPrediction = new Prediction({\n      channel: channel._id,\n      title: 'Prediction Session',\n      openedBy: owner._id,\n      status: 'open'\n    });\n    \n    await newPrediction.save();\n    \n    // Update channel\n    channel.currentPrediction = newPrediction._id;\n    await channel.save();\n    \n    // Emit WebSocket event\n    const io = req.app.get('io');\n    if (io) {\n      io.to(`channel:${channelName}`).emit('prediction-opened', {\n        channel: channelName,\n        predictionId: newPrediction._id\n      });\n    }\n    \n    sendLegacyResponse(res, 'New Prediction is now opened, and all previous predictions have been cleared!');\n  } catch (error) {\n    console.error('Error opening prediction:', error);\n    sendLegacyResponse(res, 'Error opening prediction. Please try again.');\n  }\n});\n\n// Route: Close prediction\nrouter.get('/:channel/close', adminLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    if (!prediction) {\n      sendLegacyResponse(res, 'No active prediction to close.');\n      return;\n    }\n    \n    if (prediction.status !== 'open') {\n      sendLegacyResponse(res, 'Prediction is already closed.');\n      return;\n    }\n    \n    prediction.status = 'closed';\n    prediction.closedAt = new Date();\n    await prediction.save();\n    \n    // Emit WebSocket event\n    const io = req.app.get('io');\n    if (io) {\n      io.to(`channel:${channelName}`).emit('prediction-closed', {\n        channel: channelName,\n        predictionId: prediction._id\n      });\n    }\n    \n    sendLegacyResponse(res, 'Predictions have been closed!');\n  } catch (error) {\n    console.error('Error closing prediction:', error);\n    sendLegacyResponse(res, 'Error closing prediction. Please try again.');\n  }\n});\n\n// Route: Add prediction\nrouter.get('/:channel/add', predictionLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const username = req.query.username;\n    const predictionValue = req.query.prediction;\n    \n    if (!username || !predictionValue) {\n      sendLegacyResponse(res, 'Please provide username and prediction with format: xx-xx. Example: !addpredict 13-9');\n      return;\n    }\n    \n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    if (!prediction) {\n      sendLegacyResponse(res, 'No active prediction session. Please wait for one to be opened.');\n      return;\n    }\n    \n    if (prediction.status !== 'open') {\n      sendLegacyResponse(res, 'Predictions have been closed!');\n      return;\n    }\n    \n    if (!isValidPredictionFormat(predictionValue, prediction.maxScore)) {\n      sendLegacyResponse(res, `Prediction format is invalid for ${username}. Use the allowed formats, xx-xx. Each side must be either in ${prediction.maxScore}.`);\n      return;\n    }\n    \n    // Check if user already has a prediction\n    const existingEntry = prediction.entries.find(entry => entry.username === username.toLowerCase());\n    if (existingEntry) {\n      sendLegacyResponse(res, `${username}: You have already submitted your prediction: ${existingEntry.prediction}`);\n      return;\n    }\n    \n    // Add prediction\n    const user = await getOrCreateUser(username);\n    await prediction.addEntry(user, username, predictionValue);\n    \n    // Emit WebSocket event\n    const io = req.app.get('io');\n    if (io) {\n      io.to(`channel:${channelName}`).emit('prediction-added', {\n        channel: channelName,\n        username,\n        prediction: predictionValue\n      });\n    }\n    \n    sendLegacyResponse(res, `Prediction added successfully for ${username}. Your prediction: ${predictionValue}`);\n  } catch (error) {\n    console.error('Error adding prediction:', error);\n    sendLegacyResponse(res, 'Error adding prediction. Please try again.');\n  }\n});\n\n// Route: Edit prediction\nrouter.get('/:channel/edit', predictionLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const username = req.query.username;\n    const newPrediction = req.query.prediction;\n    \n    if (!username || !newPrediction) {\n      sendLegacyResponse(res, 'Please provide username and prediction.');\n      return;\n    }\n    \n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    if (!prediction) {\n      sendLegacyResponse(res, 'No active prediction session.');\n      return;\n    }\n    \n    if (prediction.status !== 'open') {\n      sendLegacyResponse(res, `${username}: Predictions are closed. You cannot edit predictions.`);\n      return;\n    }\n    \n    if (!isValidPredictionFormat(newPrediction, prediction.maxScore)) {\n      sendLegacyResponse(res, `Prediction format is invalid for ${username}. Use the allowed formats, xx-xx. Each side must be either in ${prediction.maxScore}.`);\n      return;\n    }\n    \n    // Find existing entry\n    const entryIndex = prediction.entries.findIndex(entry => entry.username === username.toLowerCase());\n    if (entryIndex === -1) {\n      sendLegacyResponse(res, `Prediction for ${username} is not found.`);\n      return;\n    }\n    \n    // Update prediction\n    prediction.entries[entryIndex].prediction = newPrediction;\n    prediction.entries[entryIndex].editedAt = new Date();\n    await prediction.save();\n    \n    // Emit WebSocket event\n    const io = req.app.get('io');\n    if (io) {\n      io.to(`channel:${channelName}`).emit('prediction-edited', {\n        channel: channelName,\n        username,\n        prediction: newPrediction\n      });\n    }\n    \n    sendLegacyResponse(res, `Prediction edited successfully for ${username}. New prediction: ${newPrediction}`);\n  } catch (error) {\n    console.error('Error editing prediction:', error);\n    sendLegacyResponse(res, 'Error editing prediction. Please try again.');\n  }\n});\n\n// Route: List predictions\nrouter.get('/:channel/list', async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    if (!prediction || prediction.entries.length === 0) {\n      sendLegacyResponse(res, `Predictions are empty for channel, ${channelName}.`);\n      return;\n    }\n    \n    const predictionList = prediction.entries.map(entry => `${entry.username}: ${entry.prediction}`).join(', ');\n    sendLegacyResponse(res, `[Current Predictions] ${predictionList}`);\n  } catch (error) {\n    console.error('Error listing predictions:', error);\n    sendLegacyResponse(res, 'Error retrieving predictions.');\n  }\n});\n\n// Route: Check status\nrouter.get('/:channel/status', async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    const statusMessage = (prediction && prediction.status === 'open')\n      ? 'Predictions are currently open.'\n      : 'Predictions are currently closed.';\n    \n    sendLegacyResponse(res, statusMessage);\n  } catch (error) {\n    console.error('Error checking status:', error);\n    sendLegacyResponse(res, 'Error checking prediction status.');\n  }\n});\n\n// Route: Set result\nrouter.get('/:channel/result', adminLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const actualResult = req.query.result;\n    \n    if (!actualResult) {\n      sendLegacyResponse(res, 'Please provide the actual result.');\n      return;\n    }\n    \n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    if (!prediction) {\n      sendLegacyResponse(res, 'No prediction to resolve.');\n      return;\n    }\n    \n    if (prediction.status === 'open') {\n      sendLegacyResponse(res, 'Predictions are still open. Results will be available after closing predictions.');\n      return;\n    }\n    \n    const owner = await User.findById(channel.owner);\n    await prediction.resolveWith(actualResult, owner._id);\n    \n    const winners = prediction.getWinners();\n    \n    // Emit WebSocket event\n    const io = req.app.get('io');\n    if (io) {\n      io.to(`channel:${channelName}`).emit('prediction-resolved', {\n        channel: channelName,\n        result: actualResult,\n        winners: winners.map(w => w.username)\n      });\n    }\n    \n    if (winners.length > 0) {\n      const winnerUsernames = winners.map(winner => winner.username).join(', ');\n      sendLegacyResponse(res, `[Prediction Result] Winners: ${winnerUsernames}. Actual Result: ${actualResult}`);\n    } else {\n      sendLegacyResponse(res, `[Prediction Result] No winners. Actual Result: ${actualResult}`);\n    }\n  } catch (error) {\n    console.error('Error setting result:', error);\n    sendLegacyResponse(res, 'Error setting prediction result.');\n  }\n});\n\n// Route: Force add by owner\nrouter.get('/:channel/addByOwner', adminLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const targetUsername = req.query.username?.replace('@', '');\n    const predictionValue = req.query.prediction;\n    \n    if (!targetUsername || !predictionValue) {\n      sendLegacyResponse(res, 'Please provide username and prediction with format: xx-xx. Example: !fpredict username 13-9');\n      return;\n    }\n    \n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    if (!prediction) {\n      sendLegacyResponse(res, 'No active prediction session.');\n      return;\n    }\n    \n    if (!isValidPredictionFormat(predictionValue, prediction.maxScore)) {\n      sendLegacyResponse(res, `Prediction format is invalid for ${targetUsername}. Use the allowed formats, xx-xx. Each side must be either in ${prediction.maxScore}.`);\n      return;\n    }\n    \n    // Force add/update prediction (owners can override)\n    const user = await getOrCreateUser(targetUsername);\n    await prediction.addEntry(user, targetUsername, predictionValue);\n    \n    sendLegacyResponse(res, `Prediction added successfully for ${targetUsername}. Prediction: ${predictionValue}`);\n  } catch (error) {\n    console.error('Error force adding prediction:', error);\n    sendLegacyResponse(res, 'Error adding prediction.');\n  }\n});\n\n// Route: Force add by mods\nrouter.get('/:channel/addByMods', adminLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const modUsername = req.query.mods;\n    const targetUsername = req.query.username?.replace('@', '');\n    const predictionValue = req.query.prediction;\n    \n    if (!targetUsername || !predictionValue) {\n      sendLegacyResponse(res, 'Please provide username and prediction.');\n      return;\n    }\n    \n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    if (!prediction) {\n      sendLegacyResponse(res, 'No active prediction session.');\n      return;\n    }\n    \n    if (!isValidPredictionFormat(predictionValue, prediction.maxScore)) {\n      sendLegacyResponse(res, `Prediction format is invalid for ${targetUsername}. Use the allowed formats, xx-xx.`);\n      return;\n    }\n    \n    const user = await getOrCreateUser(targetUsername);\n    await prediction.addEntry(user, targetUsername, predictionValue);\n    \n    sendLegacyResponse(res, `Prediction added successfully for ${targetUsername} by ${channelName}'s Mod, ${modUsername}. Prediction: ${predictionValue}`);\n  } catch (error) {\n    console.error('Error mod adding prediction:', error);\n    sendLegacyResponse(res, 'Error adding prediction.');\n  }\n});\n\n// Route: Force add by admins\nrouter.get('/:channel/addByAdmins', adminLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const adminUsername = req.query.admins;\n    const targetUsername = req.query.username?.replace('@', '');\n    const predictionValue = req.query.prediction;\n    \n    if (!targetUsername || !predictionValue) {\n      sendLegacyResponse(res, 'Please provide username and prediction with format: xx-xx. Example: !fadminpredict username 13-9');\n      return;\n    }\n    \n    const channel = await getOrCreateChannel(channelName);\n    const prediction = await getCurrentPrediction(channel);\n    \n    if (!prediction) {\n      sendLegacyResponse(res, 'No active prediction session.');\n      return;\n    }\n    \n    // Check if admin is in admin list (simplified for legacy compatibility)\n    const adminUser = await User.findOne({ username: adminUsername.toLowerCase() });\n    if (!adminUser) {\n      sendLegacyResponse(res, `Access denied. ${adminUsername} must be listed in the ${channelName}'s admin list.`);\n      return;\n    }\n    \n    if (!isValidPredictionFormat(predictionValue, prediction.maxScore)) {\n      sendLegacyResponse(res, `Prediction format is invalid for ${targetUsername}. Use the allowed formats, xx-xx.`);\n      return;\n    }\n    \n    const user = await getOrCreateUser(targetUsername);\n    await prediction.addEntry(user, targetUsername, predictionValue);\n    \n    sendLegacyResponse(res, `Prediction added successfully for ${targetUsername} by ${channelName}'s Prediction System Admin, ${adminUsername}. Prediction: ${predictionValue}`);\n  } catch (error) {\n    console.error('Error admin adding prediction:', error);\n    sendLegacyResponse(res, 'Error adding prediction.');\n  }\n});\n\n// Admin management routes\nrouter.get('/:channel/admin/addAdmin', adminLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const adminUsername = req.query.username?.replace('@', '').toLowerCase();\n    \n    if (!adminUsername) {\n      sendLegacyResponse(res, 'Please provide a username.');\n      return;\n    }\n    \n    const channel = await getOrCreateChannel(channelName);\n    const adminUser = await getOrCreateUser(adminUsername);\n    \n    // Check if already admin\n    if (channel.isAdmin(adminUser._id)) {\n      sendLegacyResponse(res, `Admin ${adminUsername} is already in ${channelName}'s Prediction System!`);\n      return;\n    }\n    \n    // Add admin\n    channel.admins.push({\n      user: adminUser._id,\n      addedBy: channel.owner\n    });\n    await channel.save();\n    \n    sendLegacyResponse(res, `Admin ${adminUsername} added successfully into ${channelName}'s Prediction System!`);\n  } catch (error) {\n    console.error('Error adding admin:', error);\n    sendLegacyResponse(res, 'Error adding admin.');\n  }\n});\n\nrouter.get('/:channel/admin/removeAdmin', adminLimiter, async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const adminUsername = req.query.username?.replace('@', '').toLowerCase();\n    \n    if (!adminUsername) {\n      sendLegacyResponse(res, 'Please provide a username.');\n      return;\n    }\n    \n    const channel = await getOrCreateChannel(channelName);\n    const adminUser = await User.findOne({ username: adminUsername });\n    \n    if (!adminUser || !channel.isAdmin(adminUser._id)) {\n      sendLegacyResponse(res, `Admin ${adminUsername} is not in ${channelName}'s Prediction System!`);\n      return;\n    }\n    \n    // Remove admin\n    channel.admins = channel.admins.filter(admin => !admin.user.equals(adminUser._id));\n    await channel.save();\n    \n    sendLegacyResponse(res, `Admin ${adminUsername} removed successfully into ${channelName}'s Prediction System!.`);\n  } catch (error) {\n    console.error('Error removing admin:', error);\n    sendLegacyResponse(res, 'Error removing admin.');\n  }\n});\n\nrouter.get('/:channel/admin/list', async (req, res) => {\n  try {\n    const channelName = req.params.channel;\n    const channel = await getOrCreateChannel(channelName);\n    \n    // Populate admin users\n    await channel.populate('admins.user', 'username');\n    \n    const adminList = channel.admins.map(admin => admin.user.username);\n    \n    if (adminList.length === 0) {\n      sendLegacyResponse(res, `${channelName}'s Prediction Admins: None`);\n    } else {\n      sendLegacyResponse(res, `${channelName}'s Prediction Admins: ${adminList.join(', ')}`);\n    }\n  } catch (error) {\n    console.error('Error listing admins:', error);\n    sendLegacyResponse(res, 'Error retrieving admin list.');\n  }\n});\n\nmodule.exports = router;